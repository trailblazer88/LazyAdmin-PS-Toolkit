using namespace System.Windows.Forms
using namespace System.Drawing
using namespace System.Timers

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

$form = New-Object Form
$form.Text = "AD Lockout & Bad Password Tracer"
$form.Size = New-Object Size(1050, 720)
$form.StartPosition = "CenterScreen"
$form.Font = New-Object Font("Segoe UI", 10)
$form.BackColor = [Color]::White
$form.MinimumSize = New-Object Size(1050, 720)

# Panel for inputs at the top
$inputPanel = New-Object Panel
$inputPanel.Location = New-Object Point(10, 10)
$inputPanel.Size = New-Object Size(1020, 70)
$inputPanel.Anchor = 'Top, Left, Right'
$form.Controls.Add($inputPanel)

# Username label and textbox
$lblUser = New-Object Label
$lblUser.Text = "Username:"
$lblUser.Location = New-Object Point(10, 20)
$lblUser.AutoSize = $true
$inputPanel.Controls.Add($lblUser)

$txtUser = New-Object TextBox
$txtUser.Location = New-Object Point(90, 15)
$txtUser.Size = New-Object Size(180, 25)
$inputPanel.Controls.Add($txtUser)

# Domain label and combobox
$lblDomain = New-Object Label
$lblDomain.Text = "Domain:"
$lblDomain.Location = New-Object Point(290, 20)
$lblDomain.AutoSize = $true
$inputPanel.Controls.Add($lblDomain)

$cmbDomain = New-Object ComboBox
$cmbDomain.Location = New-Object Point(350, 15)
$cmbDomain.Size = New-Object Size(200, 25)
$cmbDomain.DropDownStyle = 'DropDownList'
$inputPanel.Controls.Add($cmbDomain)

# From date label and picker
$lblFrom = New-Object Label
$lblFrom.Text = "From:"
$lblFrom.Location = New-Object Point(570, 20)
$lblFrom.AutoSize = $true
$inputPanel.Controls.Add($lblFrom)

$dtpFrom = New-Object DateTimePicker
$dtpFrom.Location = New-Object Point(620, 15)
$dtpFrom.Size = New-Object Size(130, 25)
$dtpFrom.Value = (Get-Date).AddDays(-1)
$inputPanel.Controls.Add($dtpFrom)

# To date label and picker
$lblTo = New-Object Label
$lblTo.Text = "To:"
$lblTo.Location = New-Object Point(770, 20)
$lblTo.AutoSize = $true
$inputPanel.Controls.Add($lblTo)

$dtpTo = New-Object DateTimePicker
$dtpTo.Location = New-Object Point(800, 15)
$dtpTo.Size = New-Object Size(130, 25)
$dtpTo.Value = Get-Date
$inputPanel.Controls.Add($dtpTo)

# Run button
$btnRun = New-Object Button
$btnRun.Text = "Run Trace"
$btnRun.Location = New-Object Point(950, 15)
$btnRun.Size = New-Object Size(60, 30)
$inputPanel.Controls.Add($btnRun)

# Panels for the two list views side by side
$dcPanel = New-Object Panel
$dcPanel.Location = New-Object Point(10, 90)
$dcPanel.Size = New-Object Size(500, 550)
$dcPanel.Anchor = 'Top, Left, Bottom'
$form.Controls.Add($dcPanel)

$eventPanel = New-Object Panel
$eventPanel.Location = New-Object Point(520, 90)
$eventPanel.Size = New-Object Size(510, 550)
$eventPanel.Anchor = 'Top, Right, Bottom'
$form.Controls.Add($eventPanel)

# DC ListView
$lvDC = New-Object ListView
$lvDC.View = 'Details'
$lvDC.FullRowSelect = $true
$lvDC.GridLines = $true
$lvDC.Dock = 'Fill'
$lvDC.Columns.Add("Domain Controller", 230) | Out-Null
$lvDC.Columns.Add("Status", 240) | Out-Null
$dcPanel.Controls.Add($lvDC)

# Event ListView
$lvEvt = New-Object ListView
$lvEvt.View = 'Details'
$lvEvt.FullRowSelect = $true
$lvEvt.GridLines = $true
$lvEvt.Dock = 'Fill'
"DC","Caller","Time","EventID","Reason" | ForEach-Object { $lvEvt.Columns.Add($_,100) | Out-Null }
$eventPanel.Controls.Add($lvEvt)

# Progress bar below input panel, spanning width
$progress = New-Object ProgressBar
$progress.Location = New-Object Point(10, 660)
$progress.Size = New-Object Size(1000, 20)
$progress.Anchor = 'Bottom, Left, Right'
$form.Controls.Add($progress)

# Status bar at the bottom
$statusBar = New-Object StatusStrip
$statusBar.Location = New-Object Point(0, 685)
$statusBar.Size = New-Object Size(1040, 25)
$statusBar.Anchor = 'Bottom, Left, Right'
$form.Controls.Add($statusBar)

# Status labels
$statusLabel = New-Object ToolStripStatusLabel
$statusLabel.Text = "Ready"
$statusBar.Items.Add($statusLabel)

$statusDCLabel = New-Object ToolStripStatusLabel
$statusDCLabel.Text = ""
$statusBar.Items.Add($statusDCLabel)

# Export CSV button at bottom left (above progress bar)
$btnExport = New-Object Button
$btnExport.Text = "Export CSV"
$btnExport.Location = New-Object Point(10, 620)
$btnExport.Size = New-Object Size(100, 30)
$btnExport.Enabled = $false
$btnExport.Anchor = 'Bottom, Left'
$form.Controls.Add($btnExport)

# Populate domain list
try {
    $forest = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()
    foreach ($domain in $forest.Domains) {
        $cmbDomain.Items.Add($domain.Name) | Out-Null
    }
    if ($cmbDomain.Items.Count -gt 0) { $cmbDomain.SelectedIndex = 0 }
} catch {
    [MessageBox]::Show("Error loading domain list:`n$($_.Exception.Message)")
}

# Runspace pool
$runspacePool = [runspacefactory]::CreateRunspacePool(1, [environment]::ProcessorCount)
$runspacePool.Open()

function Invoke-LockoutQueryAsync {
    param($user, $domain, $from, $to, $eventIds, $progressUpdateCallback)

    $ps = [powershell]::Create()
    $ps.RunspacePool = $runspacePool

    $scriptBlock = {
        param($user, $domain, $from, $to, $eventIds)

        $results = @()
        $statuses = @()

        try {
            $forest = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()
            $targetDomain = $forest.Domains | Where-Object { $_.Name -ieq $domain }
            if (-not $targetDomain) {
                throw "Domain '$domain' not found in forest."
            }

            $dcs = $targetDomain.DomainControllers
            foreach ($dc in $dcs) {
                # Report current DC to GUI (via progress update)
                Write-Progress -Activity "Querying DCs" -Status "Processing $($dc.Name)" -PercentComplete 0

                $status = "Success"
                try {
                    $logs = Get-WinEvent -ComputerName $dc.Name -FilterHashtable @{
                        LogName='Security'; ID=$eventIds; StartTime=$from; EndTime=$to
                    } -ErrorAction Stop

                    foreach ($log in $logs) {
                        $xml = [xml]$log.ToXml()
                        $target = ($xml.Event.EventData.Data | Where-Object Name -eq "TargetUserName").'#text'
                        if ($target -ieq $user) {
                            $caller = ($xml.Event.EventData.Data | Where-Object Name -match "CallerComputerName|WorkstationName|Workstation").'#text'
                            $reason = switch ($log.Id) {
                                4740 { 'Lockout' }
                                4625 { 'Failed Logon' }
                                4771 { 'Kerberos Fail' }
                                4776 { 'NTLM Fail' }
                                default { 'Other' }
                            }
                            $results += [pscustomobject]@{
                                DC = $dc.Name
                                Caller = $caller
                                Time = $log.TimeCreated
                                EventID = $log.Id
                                Reason = $reason
                            }
                        }
                    }
                } catch {
                    $status = "Error: $($_.Exception.Message -split '\n')[0]"
                }
                $statuses += [pscustomobject]@{ DC = $dc.Name; Status = $status }

                # Update progress - invoke callback in parent runspace
                # Since this runs in different runspace, it cannot update GUI directly
                # We use Write-Progress but it won't update GUI; better approach: see below
            }

            return @{ Results = $results; Statuses = $statuses }
        }
        catch {
            return @{ Results = @(); Statuses = @([pscustomobject]@{ DC = 'N/A'; Status = $_.Exception.Message }) }
        }
    }

    $ps.AddScript($scriptBlock).AddArgument($user).AddArgument($domain).AddArgument($from).AddArgument($to).AddArgument($eventIds) | Out-Null

    $asyncResult = $ps.BeginInvoke()

    return @{ PowerShell = $ps; AsyncResult = $asyncResult }
}

# Run button click handler
$btnRun.Add_Click({
    $user = $txtUser.Text.Trim()
    $domain = $cmbDomain.SelectedItem
    $from = $dtpFrom.Value
    $to = $dtpTo.Value
    $eventIds = 4740,4625,4771,4776

    if (-not $user) { [MessageBox]::Show("Please enter a username."); return }
    if (-not $domain) { [MessageBox]::Show("Please select a domain."); return }
    if ($from -gt $to) { [MessageBox]::Show("'From' date must be before 'To'"); return }

    $btnRun.Enabled = $false
    $btnExport.Enabled = $false
    $lvDC.Items.Clear()
    $lvEvt.Items.Clear()
    $progress.Style = 'Marquee'
    $statusLabel.Text = "Running..."
    $statusDCLabel.Text = ""

    $job = Invoke-LockoutQueryAsync -user $user -domain $domain -from $from -to $to -eventIds $eventIds

    # Timer to poll for completion and update UI
    $timer = New-Object Timers.Timer
    $timer.Interval = 500
    $timer.AutoReset = $true
    $timer.Enabled = $true

    $timer.Add_Elapsed({
        if ($job.AsyncResult.IsCompleted) {
            $timer.Stop()
            $timer.Dispose()
            $progress.Style = 'Blocks'

            $output = $job.PowerShell.EndInvoke($job.AsyncResult)
            $job.PowerShell.Dispose()

            $form.Invoke([action]{
                foreach ($dc in $output.Statuses) {
                    $item = New-Object ListViewItem($dc.DC)
                    $item.SubItems.Add($dc.Status)
                    if ($dc.Status -like "Error*") { $item.BackColor = "LightSalmon" }
                    elseif ($dc.Status -eq "Success") { $item.BackColor = "LightGreen" }
                    $lvDC.Items.Add($item)
                }

                foreach ($evt in $output.Results) {
                    $item = New-Object ListViewItem($evt.DC)
                    $item.SubItems.AddRange(@($evt.Caller, $evt.Time.ToString("g"), $evt.EventID, $evt.Reason))
                    $lvEvt.Items.Add($item)
                }

                $statusLabel.Text = "Completed."
                $statusDCLabel.Text = ""
                $btnRun.Enabled = $true
                $btnExport.Enabled = $lvEvt.Items.Count -gt 0
            })
        } else {
            # We can't update current DC from inside the remote runspace, so just keep marquee style progress
            # If you want to show live DC being queried, we'd need a more complex callback or runspace event mechanism
            $form.Invoke([action]{
                $statusDCLabel.Text = "Processing domain controllers..."
            })
        }
    })
})

# Export CSV button
$btnExport.Add_Click({
    if ($lvEvt.Items.Count -eq 0) {
        [MessageBox]::Show("No events to export.")
        return
    }
    $dlg = New-Object SaveFileDialog
    $dlg.Filter = "CSV Files|*.csv"
    $dlg.FileName = "LockoutEvents.csv"
    if ($dlg.ShowDialog() -eq [DialogResult]::OK) {
        $lines = @()
        $header = "DC,Caller,Time,EventID,Reason"
        $lines += $header
        foreach ($item in $lvEvt.Items) {
            $line = ($item.SubItems | ForEach-Object { $_.Text }) -join ","
            $lines += $line
        }
        $lines | Out-File -FilePath $dlg.FileName -Encoding UTF8
        [MessageBox]::Show("Exported to $($dlg.FileName)")
    }
})

# Show form
[void]$form.ShowDialog()

# Cleanup runspace pool
$runspacePool.Close()
$runspacePool.Dispose()
